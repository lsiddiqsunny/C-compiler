Line at 1 : type_specifier	: INT

int 

Line at 1 : type_specifier	: INT

int 

Line at 1 : parameter_list->type_specifier ID

int  a

 New ScopeTable with id 2 created

Line at 2 : factor->CONST_INT

2

Line at 2 : unary_expression->factor

2

Line at 2 : term->unary_expression

2

Line at 2 : variable->ID

a

Line at 2 : factor->variable

a

Line at 2 : unary_expression->factor

a

Line at 2 : term->term MULOP unary_expression

2*a

Line at 2 : simple_expression->term

2*a

Line at 2 : rel_expression->simple_expression

2*a

Line at 2 : logic_expression->rel_expression

2*a

Line at 2 : expression->logic_expression

2*a

Line at 2 : statement->RETURN expression SEMICOLON

return 2*a;

Line at 2 : statements->statement

return 2*a;

Line at 3 : variable->ID

a

Line at 3 : factor->CONST_INT

9

Line at 3 : unary_expression->factor

9

Line at 3 : term->unary_expression

9

Line at 3 : simple_expression->term

9

Line at 3 : rel_expression->simple_expression

9

Line at 3 : logic_expression->rel_expression

9

Line at 3 : expression->variable ASSIGNOP logic_expression

a=9

Line at 3 : expression_statement->expression SEMICOLON

a=9;

Line at 3 : statement -> expression_statement

a=9;

Line at 3 : statements->statements statement

return 2*a; a=9;

Line at 4 : compound_statement->LCURL statements RCURL

{return 2*a;
a=9;}

 ScopeTable# 2 
 51  --> < ID : a > 

 ScopeTable# 1 
 56  --> < ID : f > 

 ScopeTable with id 2 removed

Line at 4 : func_definition->type_specifier ID LPAREN parameter_list RPAREN compound_statement 

int  f(int  a) {
return 2*a;
a=9;
} 

Line at 4 : unit->func_definition

int  f(int  a){
return 2*a;
a=9;
}

Line at 4 : program->unit

int  f(int  a){
return 2*a;
a=9;
}


Line at 6 : type_specifier	: INT

int 

Line at 6 : type_specifier	: INT

int 

Line at 6 : parameter_list->type_specifier ID

int  a

Line at 6 : type_specifier	: INT

int 

Line at 6 : parameter_list->parameter_list COMMA type_specifier ID

int  a,int  b

 New ScopeTable with id 3 created

Line at 7 : type_specifier	: INT

int 

Line at 7 : declaration_list->ID

x

Line at 7 : var_declaration->type_specifier declaration_list SEMICOLON

int  x;

Line at 7 : statement -> var_declaration

int  x;

Line at 7 : statements->statement

int  x;

Line at 8 : variable->ID

x

Line at 8 : variable->ID

a

Line at 8 : factor->variable

a

Line at 8 : unary_expression->factor

a

Line at 8 : term->unary_expression

a

Line at 8 : simple_expression->term

a

Line at 8 : rel_expression->simple_expression

a

Line at 8 : logic_expression->rel_expression

a

Line at 8 : arguments->logic_expression

a

Line at 8 : argument_list->arguments

a

Line at 8 : factor->ID LPAREN argument_list RPAREN

f(a)

Line at 8 : unary_expression->factor

f(a)

Line at 8 : term->unary_expression

f(a)

Line at 8 : simple_expression->term

f(a)

Line at 8 : variable->ID

a

Line at 8 : factor->variable

a

Line at 8 : unary_expression->factor

a

Line at 8 : term->unary_expression

a

Line at 8 : simple_expression->simple_expression ADDOP term

f(a)+a

Line at 8 : variable->ID

b

Line at 8 : factor->variable

b

Line at 8 : unary_expression->factor

b

Line at 8 : term->unary_expression

b

Line at 8 : simple_expression->simple_expression ADDOP term

f(a)+a+b

Line at 8 : rel_expression->simple_expression

f(a)+a+b

Line at 8 : logic_expression->rel_expression

f(a)+a+b

Line at 8 : expression->variable ASSIGNOP logic_expression

x=f(a)+a+b

Line at 8 : expression_statement->expression SEMICOLON

x=f(a)+a+b;

Line at 8 : statement -> expression_statement

x=f(a)+a+b;

Line at 8 : statements->statements statement

int  x; x=f(a)+a+b;

Line at 9 : variable->ID

x

Line at 9 : factor->variable

x

Line at 9 : unary_expression->factor

x

Line at 9 : term->unary_expression

x

Line at 9 : simple_expression->term

x

Line at 9 : rel_expression->simple_expression

x

Line at 9 : logic_expression->rel_expression

x

Line at 9 : expression->logic_expression

x

Line at 9 : statement->RETURN expression SEMICOLON

return x;

Line at 9 : statements->statements statement

int  x;
x=f(a)+a+b; return x;

Line at 10 : compound_statement->LCURL statements RCURL

{int  x;
x=f(a)+a+b;
return x;}

 ScopeTable# 3 
 51  --> < ID : a > 
 52  --> < ID : b > 
 74  --> < ID : x > 

 ScopeTable# 1 
 56  --> < ID : f > 
 57  --> < ID : g > 

 ScopeTable with id 3 removed

Line at 10 : func_definition->type_specifier ID LPAREN parameter_list RPAREN compound_statement 

int  g(int  a,int  b) {
int  x;
x=f(a)+a+b;
return x;
} 

Line at 10 : unit->func_definition

int  g(int  a,int  b){
int  x;
x=f(a)+a+b;
return x;
}

Line at 10 : program->program unit

int  f(int  a){
return 2*a;
a=9;
}
 int  g(int  a,int  b){
int  x;
x=f(a)+a+b;
return x;
}


Line at 12 : type_specifier	: INT

int 

 New ScopeTable with id 4 created

Line at 13 : type_specifier	: INT

int 

Line at 13 : declaration_list->ID

a

Line at 13 : declaration_list->declaration_list COMMA ID

a,b

Line at 13 : var_declaration->type_specifier declaration_list SEMICOLON

int  a,b;

Line at 13 : statement -> var_declaration

int  a,b;

Line at 13 : statements->statement

int  a,b;

Line at 14 : variable->ID

a

Line at 14 : factor->CONST_INT

1

Line at 14 : unary_expression->factor

1

Line at 14 : term->unary_expression

1

Line at 14 : simple_expression->term

1

Line at 14 : rel_expression->simple_expression

1

Line at 14 : logic_expression->rel_expression

1

Line at 14 : expression->variable ASSIGNOP logic_expression

a=1

Line at 14 : expression_statement->expression SEMICOLON

a=1;

Line at 14 : statement -> expression_statement

a=1;

Line at 14 : statements->statements statement

int  a,b; a=1;

Line at 15 : variable->ID

b

Line at 15 : factor->CONST_INT

2

Line at 15 : unary_expression->factor

2

Line at 15 : term->unary_expression

2

Line at 15 : simple_expression->term

2

Line at 15 : rel_expression->simple_expression

2

Line at 15 : logic_expression->rel_expression

2

Line at 15 : expression->variable ASSIGNOP logic_expression

b=2

Line at 15 : expression_statement->expression SEMICOLON

b=2;

Line at 15 : statement -> expression_statement

b=2;

Line at 15 : statements->statements statement

int  a,b;
a=1; b=2;

Line at 16 : variable->ID

a

Line at 16 : variable->ID

a

Line at 16 : factor->variable

a

Line at 16 : unary_expression->factor

a

Line at 16 : term->unary_expression

a

Line at 16 : simple_expression->term

a

Line at 16 : rel_expression->simple_expression

a

Line at 16 : logic_expression->rel_expression

a

Line at 16 : arguments->logic_expression

a

Line at 16 : variable->ID

b

Line at 16 : factor->variable

b

Line at 16 : unary_expression->factor

b

Line at 16 : term->unary_expression

b

Line at 16 : simple_expression->term

b

Line at 16 : rel_expression->simple_expression

b

Line at 16 : logic_expression->rel_expression

b

Line at 16 : arguments->arguments COMMA logic_expression 

a,b

Line at 16 : argument_list->arguments

a,b

Line at 16 : factor->ID LPAREN argument_list RPAREN

g(a,b)

Line at 16 : unary_expression->factor

g(a,b)

Line at 16 : term->unary_expression

g(a,b)

Line at 16 : simple_expression->term

g(a,b)

Line at 16 : rel_expression->simple_expression

g(a,b)

Line at 16 : logic_expression->rel_expression

g(a,b)

Line at 16 : expression->variable ASSIGNOP logic_expression

a=g(a,b)

Line at 16 : expression_statement->expression SEMICOLON

a=g(a,b);

Line at 16 : statement -> expression_statement

a=g(a,b);

Line at 16 : statements->statements statement

int  a,b;
a=1;
b=2; a=g(a,b);

Line at 17 : statement->PRINTLN LPAREN ID RPAREN SEMICOLON


 (a);

Line at 17 : statements->statements statement

int  a,b;
a=1;
b=2;
a=g(a,b); println(a)

Line at 18 : factor->CONST_INT

0

Line at 18 : unary_expression->factor

0

Line at 18 : term->unary_expression

0

Line at 18 : simple_expression->term

0

Line at 18 : rel_expression->simple_expression

0

Line at 18 : logic_expression->rel_expression

0

Line at 18 : expression->logic_expression

0

Line at 18 : statement->RETURN expression SEMICOLON

return 0;

Line at 18 : statements->statements statement

int  a,b;
a=1;
b=2;
a=g(a,b);
println(a) return 0;

Line at 19 : compound_statement->LCURL statements RCURL

{int  a,b;
a=1;
b=2;
a=g(a,b);
println(a)
return 0;}

 ScopeTable# 4 
 51  --> < ID : a > 
 52  --> < ID : b > 

 ScopeTable# 1 
 56  --> < ID : f > 
 57  --> < ID : g > 
 64  --> < ID : main > 

 ScopeTable with id 4 removed

Line at 19 : func_definition->type_specifier ID LPAREN RPAREN compound_statement

int  main() {
int  a,b;
a=1;
b=2;
a=g(a,b);
println(a)
return 0;
}

Line at 19 : unit->func_definition

int  main(){
int  a,b;
a=1;
b=2;
a=g(a,b);
println(a)
return 0;
}

Line at 19 : program->program unit

int  f(int  a){
return 2*a;
a=9;
}
int  g(int  a,int  b){
int  x;
x=f(a)+a+b;
return x;
}
 int  main(){
int  a,b;
a=1;
b=2;
a=g(a,b);
println(a)
return 0;
}


 Symbol Table : 

 ScopeTable# 1 
 56  --> < ID : f > 
 57  --> < ID : g > 
 64  --> < ID : main > 

Total Lines : 19 

Total Errors : 0 

